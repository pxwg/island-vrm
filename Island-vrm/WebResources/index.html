<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      body {
          margin: 0;
          padding: 0;
          overflow: hidden;
          background: transparent;
          width: 100vw;
          height: 100vh;
      }
      canvas {
          display: block;
          width: 100% !important;
          height: 100% !important;
          touch-action: none;
      }
    </style>
    <script type="importmap">
      {
          "imports": {
              "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
              "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
              "@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@3.0.0/lib/three-vrm.module.js"
          }
      }
    </script>
  </head>
  <body>
    <!-- <div id="debug-console" style="position:absolute; top:0; left:0; color:lime; background:rgba(0,0,0,0.5); font-family:monospace; font-size:12px; pointer-events:none; z-index:999;">Initializing...</div> -->
    <script>
      function log(msg) {
          const el = document.getElementById('debug-console');
          if(el) el.innerText += '\n' + msg;
          console.log(msg);
      }
      window.onerror = function(msg, url, line) {
          log("❌ Error: " + msg + " (" + line + ")");
      };
      log("DOM Loaded.");
    </script>
    <script type="module">
      import * as THREE from 'three';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
      import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';

      log("Three.js Modules Imported.");

      try {
          const scene = new THREE.Scene();

          const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 20.0);
          const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setPixelRatio(window.devicePixelRatio);
          document.body.appendChild(renderer.domElement);

          const light = new THREE.DirectionalLight(0xffffff, 1.2);
          light.position.set(0.5, 1.0, 1.0).normalize();
          scene.add(light);
          scene.add(new THREE.AmbientLight(0xffffff, 0.6));

          const CAMERA_STATES = {
              head: { pos: new THREE.Vector3(0, 1.5, 0.6), target: new THREE.Vector3(0, 1.5, 0) },
              body: { pos: new THREE.Vector3(0, 1.3, 1.5), target: new THREE.Vector3(0, 1.0, 0) }
          };

          let currentTargetPos = CAMERA_STATES.head.pos.clone();
          let currentLookAt = CAMERA_STATES.head.target.clone();

          let lookAtLerp = new THREE.Vector3();

          camera.position.copy(currentTargetPos);
          camera.lookAt(currentLookAt);
          lookAtLerp.copy(currentLookAt);

          const loader = new GLTFLoader();
          loader.register((parser) => new VRMLoaderPlugin(parser));

          loader.load('./avatar.vrm',

          (gltf) => {
              // log("✅ VRM Loaded Success!");
              const vrm = gltf.userData.vrm;
              vrm.scene.rotation.y = Math.PI;
              scene.add(vrm.scene);
              window.currentVrm = vrm;

              // --- 1. 鲁棒的骨骼位置获取 ---
              // 能够处理标准骨骼缺失的情况，自动降级
              const getBonePos = (boneName) => {
            const node = vrm.humanoid.getRawBoneNode(boneName);
            return node ? node.getWorldPosition(new THREE.Vector3()) : null;
              };

              // 获取关键锚点
              const defaultHead = new THREE.Vector3(0, 1.5, 0);
              const defaultHips = new THREE.Vector3(0, 0.8, 0); // 假设臀部高度

              const headPos = getBonePos("head") || defaultHead;
              const hipsPos = getBonePos("hips") || defaultHips;

              // 如果没有臀部骨骼，我们假设脊柱长度约为头高的 45%
              if (!getBonePos("hips")) {
                   hipsPos.y = headPos.y * 0.55;
              }

              log(`Detected - Head: ${headPos.y.toFixed(2)}, Hips: ${hipsPos.y.toFixed(2)}`);

              // --- 2. [头部模式]：精准聚焦面部 ---
              // VRM head 骨骼在脖子根部，脸中心大约在上方 10-12cm 处
              const faceOffset = 0.05;
              const facePos = new THREE.Vector3(headPos.x, headPos.y + faceOffset, headPos.z);

              CAMERA_STATES.head.target.copy(facePos);
              // 相机与脸同高，距离 0.55m，形成亲密的肖像感
              CAMERA_STATES.head.pos.set(facePos.x, facePos.y, facePos.z + 0.55);


              // --- 3. [身体模式]：几何计算构图 (Head to Waist) ---
              // 定义我们想看到的垂直范围：
              // 上边界：头顶 (Head + 0.18m 头发余量)
              const viewTop = headPos.y + 0.18;
              // 下边界：腰部 (Hips + 0.15m 或者是 Hips 和 Head 的某个黄金分割点)
              // 这样能保证切在腰部，而不是胯部
              const viewBottom = hipsPos.y + 0.15;

              // 计算视觉中心
              const viewCenterY = (viewTop + viewBottom) / 2;
              CAMERA_STATES.body.target.set(headPos.x, viewCenterY, headPos.z);

              // 计算所需距离 (Z轴) 以填满垂直视场
              // 公式: Distance = (Height / 2) / tan(FOV / 2)
              const visibleHeight = viewTop - viewBottom;
              const fovRad = (camera.fov * Math.PI) / 180; // 将角度转换为弧度
              // 1.5 是安全系数 (padding)，避免头顶或腰部紧贴屏幕边缘
              const fitDistance = (visibleHeight / 2) / Math.tan(fovRad / 2) * 1.5;

              // 相机高度平视视觉中心，距离自动适配
              CAMERA_STATES.body.pos.set(headPos.x, viewCenterY, headPos.z + fitDistance);

              setCameraMode('head', true);

              setTimeout(() => {
            const el = document.getElementById('debug-console');
            if(el) el.style.display = 'none';
              }, 2000);
          },
              (progress) => {},
              (error) => {
                  log("❌ VRM Load Fail: " + error.message);
                  console.error(error);
              }
          );

          const clock = new THREE.Clock();
          function animate() {
              requestAnimationFrame(animate);
              const delta = clock.getDelta();
              if (window.currentVrm) window.currentVrm.update(delta);

              const damping = 0.1;

              camera.position.lerp(currentTargetPos, damping);

              lookAtLerp.lerp(currentLookAt, damping);
              camera.lookAt(lookAtLerp);

              renderer.render(scene, camera);
          }
          animate();

          window.setCameraMode = (mode, immediate = false) => {
              log("Mode: " + mode);
              const state = CAMERA_STATES[mode];
              if (state) {
                  currentTargetPos.copy(state.pos);
                  currentLookAt.copy(state.target);

                  if (immediate) {
                      camera.position.copy(currentTargetPos);
                      lookAtLerp.copy(currentLookAt);
                      camera.lookAt(lookAtLerp);
                  }
              }
          };

          window.updateSize = (w, h) => {
              camera.aspect = w / h;
              camera.updateProjectionMatrix();
              renderer.setSize(w, h);
          };

      } catch (e) {
          log("❌ Script Crash: " + e.message);
      }
    </script>
  </body>
</html>
