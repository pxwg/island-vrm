<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      body {
          margin: 0;
          padding: 0;
          overflow: hidden;
          background: transparent;
          width: 100vw;
          height: 100vh;
      }
      canvas {
          display: block;
          width: 100% !important;
          height: 100% !important;
          touch-action: none;
      }
    </style>
    <script type="importmap">
      {
          "imports": {
              "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
              "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
              "@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@3.0.0/lib/three-vrm.module.js",
              "@pixiv/three-vrm-animation": "https://unpkg.com/@pixiv/three-vrm-animation@3.0.0/lib/three-vrm-animation.module.js"
          }
      }
    </script>
  </head>
  <body>
    <script>
      function log(msg) {
          const el = document.getElementById('debug-console');
          if(el) el.innerText += '\n' + msg;
          console.log(msg);
      }
      window.onerror = function(msg, url, line) {
          log("❌ Error: " + msg + " (" + line + ")");
      };
      log("DOM Loaded.");
    </script>
    <script type="module">
      import * as THREE from 'three';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
      import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
      // 2. Import Animation Plugin and Clip Creator
      import { VRMAnimationLoaderPlugin, createVRMAnimationClip } from '@pixiv/three-vrm-animation';

      log("Three.js Modules Imported.");

      try {
          const scene = new THREE.Scene();

          const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 20.0);
          const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setPixelRatio(window.devicePixelRatio);
          document.body.appendChild(renderer.domElement);

          const light = new THREE.DirectionalLight(0xffffff, 1.2);
          light.position.set(0.5, 1.0, 1.0).normalize();
          scene.add(light);
          scene.add(new THREE.AmbientLight(0xffffff, 0.6));

          const CAMERA_STATES = {
              head: { pos: new THREE.Vector3(0, 1.5, 0.6), target: new THREE.Vector3(0, 1.5, 0) },
              body: { pos: new THREE.Vector3(0, 1.3, 1.5), target: new THREE.Vector3(0, 1.0, 0) }
          };

          let currentTargetPos = CAMERA_STATES.head.pos.clone();
          let currentLookAt = CAMERA_STATES.head.target.clone();
          let lookAtLerp = new THREE.Vector3();

          camera.position.copy(currentTargetPos);
          camera.lookAt(currentLookAt);
          lookAtLerp.copy(currentLookAt);

          // Animation Mixer State
          let currentMixer = null;

          const loader = new GLTFLoader();
          loader.register((parser) => new VRMLoaderPlugin(parser));
          // 3. Register the Animation Plugin
          loader.register((parser) => new VRMAnimationLoaderPlugin(parser));

          loader.load('./avatar.vrm',
              (gltf) => {
                  const vrm = gltf.userData.vrm;
                  vrm.scene.rotation.y = Math.PI;
                  scene.add(vrm.scene);
                  window.currentVrm = vrm;

                  // --- Robust Framing Logic (From previous step) ---
                  const getBonePos = (boneName) => {
                      const node = vrm.humanoid.getRawBoneNode(boneName);
                      return node ? node.getWorldPosition(new THREE.Vector3()) : null;
                  };

                  const defaultHead = new THREE.Vector3(0, 1.5, 0);
                  const defaultHips = new THREE.Vector3(0, 0.8, 0);
                  const headPos = getBonePos("head") || defaultHead;
                  const hipsPos = getBonePos("hips") || defaultHips;
                  if (!getBonePos("hips")) hipsPos.y = headPos.y * 0.55;

                  log(`Detected - Head: ${headPos.y.toFixed(2)}, Hips: ${hipsPos.y.toFixed(2)}`);

                  // [Head Mode]
                  const faceOffset = 0.05;
                  const facePos = new THREE.Vector3(headPos.x, headPos.y + faceOffset, headPos.z);
                  CAMERA_STATES.head.target.copy(facePos);
                  CAMERA_STATES.head.pos.set(facePos.x, facePos.y, facePos.z + 0.55);

                  // [Body Mode]
                  const viewTop = headPos.y + 0.18;
                  const viewBottom = hipsPos.y + 0.15;
                  const viewCenterY = (viewTop + viewBottom) / 2;
                  CAMERA_STATES.body.target.set(headPos.x, viewCenterY, headPos.z);

                  const visibleHeight = viewTop - viewBottom;
                  const fovRad = (camera.fov * Math.PI) / 180;
                  const fitDistance = (visibleHeight / 2) / Math.tan(fovRad / 2) * 1.5;
                  CAMERA_STATES.body.pos.set(headPos.x, viewCenterY, headPos.z + fitDistance);

                  setCameraMode('head', true);

                  // --- 4. Load Idle Animation (.vrma) ---
                  log("Loading idle.vrma...");
                  loader.load('./idle.vrma', (vrmaGltf) => {
                      const vrmAnimations = vrmaGltf.userData.vrmAnimations;
                      if (vrmAnimations && vrmAnimations[0]) {
                          log("✅ Animation Loaded.");

                          // Create Mixer
                          currentMixer = new THREE.AnimationMixer(vrm.scene);

                          // Convert VRM Animation to Three.js Clip
                          const clip = createVRMAnimationClip(vrmAnimations[0], vrm);

                          // Play Animation
                          const action = currentMixer.clipAction(clip);
                          action.play();
                      }
                  }, undefined, (err) => {
                      log("⚠️ Animation Load Failed: " + err.message);
                  });

                  setTimeout(() => {
                      const el = document.getElementById('debug-console');
                      if(el) el.style.display = 'none';
                  }, 2000);
              },
              (progress) => {},
              (error) => {
                  log("❌ VRM Load Fail: " + error.message);
                  console.error(error);
              }
          );

          const clock = new THREE.Clock();

          // Auto Blink State
          let blinkTimer = 0;
          let nextBlinkTime = 2;
          let isBlinking = false;

          function animate() {
              requestAnimationFrame(animate);
              const delta = clock.getDelta();

              if (window.currentVrm) {
                  const vrm = window.currentVrm;

                  // A. Update Animation Mixer
                  if (currentMixer) {
                      currentMixer.update(delta);
                  }

                  // B. Update VRM
                  vrm.update(delta);
              }

              const damping = 0.1;
              camera.position.lerp(currentTargetPos, damping);
              lookAtLerp.lerp(currentLookAt, damping);
              camera.lookAt(lookAtLerp);

              renderer.render(scene, camera);
          }
          animate();

          window.setCameraMode = (mode, immediate = false) => {
              log("Mode: " + mode);
              const state = CAMERA_STATES[mode];
              if (state) {
                  currentTargetPos.copy(state.pos);
                  currentLookAt.copy(state.target);
                  if (immediate) {
                      camera.position.copy(currentTargetPos);
                      lookAtLerp.copy(currentLookAt);
                      camera.lookAt(lookAtLerp);
                  }
              }
          };

          window.updateSize = (w, h) => {
              camera.aspect = w / h;
              camera.updateProjectionMatrix();
              renderer.setSize(w, h);
          };

      } catch (e) {
          log("❌ Script Crash: " + e.message);
      }
    </script>
  </body>
</html>
